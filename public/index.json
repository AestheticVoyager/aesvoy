
[{"content":"","date":"17 April 2024","externalUrl":null,"permalink":"/","section":"Aesthetic Voyager","summary":"","title":"Aesthetic Voyager","type":"page"},{"content":" Introduction # In the realm of digital image processing, dithering algorithms play a crucial role in reducing the color palette of an image while maintaining visual quality. These algorithms distribute quantization errors across neighboring pixels, resulting in visually pleasing images with fewer colors. In this blog post, we\u0026rsquo;ll delve into the implementation of two popular dithering algorithms, Floyd-Steinberg and Atkinson, using the power of Numba for performance optimization.\nUnderstanding Dithering Algorithms # Before we delve into the code, let\u0026rsquo;s briefly understand the two dithering algorithms we\u0026rsquo;ll be exploring:\nFloyd-Steinberg Dithering: Developed by Robert W. Floyd and Louis Steinberg in 1976. Distributes quantization errors to neighboring pixels in a specific pattern. Produces sharp images with noticeable noise. Atkinson Dithering: Developed by Bill Atkinson in 1982. Similar to Floyd-Steinberg but distributes errors differently. Produces smoother images with less visible noise. Implementation with Numba # Now, let\u0026rsquo;s see how we can implement these dithering algorithms efficiently using Numba, a Just-In-Time compiler for Python code.\n@numba.jit(\u0026#34;f4[:,:,:](f4[:,:,:])\u0026#34;, nopython=True, nogil=True) def floyd_steinberg(image): Lx, Ly, Lc = image.shape for j in range(Ly): for i in range(Lx): for c in range(Lc): rounded = round(image[i,j,c]) err = image[i,j,c] - rounded image[i,j,c] = rounded if i\u0026lt;Lx-1: image[i+1,j,c] += (7/16)*err if j\u0026lt;Ly-1: image[i,j+1,c] += (5/16)*err if i\u0026gt;0: image[i-1,j+1,c] += (1/16)*err if i\u0026lt;Lx-1: image[i+1,j+1,c] += (3/16)*err return image @numba.jit(\u0026#34;f4[:,:,:](f4[:,:,:])\u0026#34;, nopython=True, nogil=True) def atkinson(image): frac = 8 Lx, Ly, Lc = image.shape for j in range(Ly): for i in range(Lx): for c in range(Lc): rounded = round(image[i,j,c]) err = image[i,j,c] - rounded image[i,j,c] = rounded if i\u0026lt;Lx-1: image[i+1,j,c] += err / frac if i\u0026lt;Lx-2: image[i+2,j,c] += err /frac if j\u0026lt;Ly-1: image[i,j+1,c] += err / frac if i\u0026gt;0: image[i-1,j+1,c] += err / frac if i\u0026lt;Lx-1: image[i+1,j+1,c] += err / frac if j\u0026lt;Ly-2: image[i,j+2,c] += err / frac return image Explanation of the Code # We utilize NumPy for numerical operations, PIL (Python Imaging Library) for image loading and saving, and Numba for JIT compilation to enhance performance. Both Floyd-Steinberg and Atkinson algorithms are implemented as Numba-jitted functions. The algorithms iterate through each pixel of the image, applying error diffusion to distribute quantization errors. Finally, the processed images are saved to disk. Results \u0026amp; Conclusion # By applying Floyd-Steinberg and Atkinson dithering algorithms to an input image, we\u0026rsquo;ve successfully reduced its color palette while preserving visual quality. The utilization of Numba for performance optimization ensures efficient processing, making these algorithms suitable for large-scale image manipulation tasks.\nExperimentation with different images and tweaking parameters can yield varying results, allowing for customization based on specific requirements. Dithering algorithms continue to be relevant in various applications, including digital art, printing, and image compression.\nIn conclusion, by exploring dithering algorithms such as Floyd-Steinberg and Atkinson and leveraging the power of Numba for implementation, we\u0026rsquo;ve gained insights into enhancing image processing tasks with efficient and optimized code.\nLink to Complete Implementation in GitHub\n","date":"17 April 2024","externalUrl":null,"permalink":"/posts/dither/","section":"Posts","summary":"Dither filter","title":"Dither","type":"posts"},{"content":"","date":"17 April 2024","externalUrl":null,"permalink":"/tags/filter/","section":"Tags","summary":"","title":"Filter","type":"tags"},{"content":"The Kuwahara filter is a non-linear smoothing filter used in image processing for adaptive noise reduction. Most filters that are used for image smoothing are linear low-pass filters that effectively reduce noise but also blur out the edges. However the Kuwahara filter is able to apply smoothing on the image while preserving the edges.\nIt is named after Michiyoshi Kuwahara, Ph.D., who worked at Kyoto and Osaka Sangyo Universities in Japan, developing early medical imaging of dynamic heart muscle in the 1970s and 80s.\nKuwahara Filter description # The Kuwahara filter works on a window divided into 4 overlapping sub-windows. In each sub-window, the mean and variance are computed.\nThe output value (located at the center of the window) is set to the mean of the sub-window with the smallest variance.\nApplications # Originally the Kuwahara filter was proposed for use in processing RI-angiocardiographic images of the cardiovascular system.\nThe fact that any edges are preserved when smoothing makes it especially useful for feature extraction and segmentation and explains why it is used in medical imaging.\nThe Kuwahara filter however also finds many applications in artistic imaging and fine-art photography due to its ability to remove textures and sharpen the edges of photographs. The level of abstraction helps create a desirable painting-like effect in artistic photographs especially in the case of the colored image version of the filter. These applications have known great success and have encouraged similar research in the field of image processing for the arts.\nAlthough the vast majority of applications have been in the field of image processing there have been cases that use modifications of the Kuwahara filter for machine learning tasks such as clustering.\nThe Kuwahara filter has been implemented in CVIPtools.\nAnisotropic Kuwahara Filtering with Polynomial Weighting Functions Paper # The Anisotropic Kuwahara Paper link\nKuwahara was the world\u0026rsquo;s first edge preserving de-noising image processing algorithm. It was upgraded by the \u0026ldquo;Anisotropic Kuwahara Filtering with Polynomial Weighting Functions\u0026rdquo; paper, by:\nUpgraded by using a circular kernel instead of Box kernel. Instead of using naive weights, we use gaussian weights. This new formula: 1/(1+std_div), sector color = Ki, K(x)=(sum of Ki * Wi)/(sum of weights i) This removes indeterminate behavior and removes all conditional logic of the old algorithm. All these changes were made by Guiseppe Papari.\nThankfully we can just ditch the Gauss and instead approximate the weight using \u0026ldquo;Polynomials\u0026rdquo;.\nThen we\u0026rsquo;ll calculate the Eigen-Values. To calculate the Eigen-Values of the structure tensor and use them to calculate the eigenvectors that points in the direction of the minimum rate of change. We\u0026rsquo;re just essentially figuring out what direction a pixel points in using the eigenvector information.\nThe filter kernel can now angle itself and stretch itself to better fit image details and edges.\nThis new filter is called Anisotropic Kuwahara Filter.\nRecommendation: In-order to achieve High Contrast Visuals, it is better to apply the anisotropic kuwahara then apply the dither effect.\nMy Personal Optimized Implementation of Kuwahara filter # Personal Implementation\n","date":"17 April 2024","externalUrl":null,"permalink":"/posts/kuwahara/","section":"Posts","summary":"Kuwahara filter","title":"Kuwahara","type":"posts"},{"content":"","date":"17 April 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 April 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]